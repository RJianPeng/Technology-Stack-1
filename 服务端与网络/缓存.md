# 缓存

## 强缓存


实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200
```
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
```
Cache-control: max-age=30
```
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。

强缓存在客户端和服务器端都会存在。
* 客户端：客户端在请求资源前，会检查上一次该资源响应头的 `Cache-Control` 字段，如果该字段的值为 max-age = time，如果该资源缓存的时间没有过这个时间值，**则直接使用本地的缓存，而不像服务器发请求**。
* 服务器端：服务器端在接收到一个请求后，检查请求的头部 `Cache-Control` 字段的值 max-age = time，如果距离上一次返回资源的时间小于这个毫秒数，那么服务器不会读取新的资源，而是直接返回 304，告知客户端使用自己本地上次缓存的资源即可。


<br>

## 对比缓存
　　在没有走强缓存逻辑的情况下，服务器端会进行 `Last-Modified` 和 `Etag` 的校验，如果校验发现资源未更新，则会返回 **304** ，否则会返回新的资源实体。

### Etag
　　首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。

　　比较过程：
  * 当你第一次发起 HTTP 请求时，服务器会返回一个 Etag
  * 在你第二次发起同一个请求时，客户端会同时发送一个 If-None-Match，而它的值就是 Etag 的值（此处由发起请求的客户端来设置）。
  * 然后，服务器会比对这个客服端发送过来的 Etag 是否与服务器的相同
    * 如果相同，就将 If-None-Match 的值设为 false，返回状态码为 304，客户端继续使用本地缓存
    * 如果不相同，就将 If-None-Match 的值设为 true，返回状态为 200，客户端重新解析服务器返回的数据

### Last-Modified/If-Modified-Since
* Last-Modified：由服务器发送给客户端，表示这个响应资源的最后修改时间。 
* If-Modified-Since：由客户端发送给服务器，表示本地浏览器存储的文件修改时间。

　　比较过程：  
* 当你第一次发起 HTTP 请求时，服务器会返回一个 Last-Modified
* 在你第二次发起同一个请求时，客户端会同时发送一个 If-Modified-Since，它的值是本地浏览器存储的文件修改时间。
* 服务器比对
  * 如果两个时间相等，返回状态码为 304，客户端继续使用本地缓存
  * 如果 Last-Modified 时间更晚，返回状态为 200，客户端重新解析服务器返回的数据

<br>

### 流程图
<div align="center">
  <img src="https://github.com/TanYJie/Technology-Stack-Interview-Experience/blob/master/服务端与网络/image/HTTP缓存.png"/>
</div>
