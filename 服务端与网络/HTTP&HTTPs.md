# HTTP & HTTPS

本章内容：
  * [HTTP 请求报文](#http-请求报文)
  * [HTTP 响应报文](#http-响应报文)
  * [HTTP 版本](#http-版本迭代)
  * [HTTP 方法](#http-请求方法)
  * [HTTPS](#https)
  

## HTTP 请求报文
<div align="center">
<img src="https://github.com/TanYJie/Technology-Stack-Interview-Experience/blob/master/服务端与网络/image/HTTP请求.png"/>
</div>

<br>

## HTTP 响应报文
<div align="center">
<img src="https://github.com/TanYJie/Technology-Stack-Interview-Experience/blob/master/服务端与网络/image/HTTP响应.png"/>
</div>

<br>
<br>


## HTTP 版本迭代
### HTTP1.1 和 1.0 的区别
* 缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。（关于[缓存](https://github.com/TanYJie/Technology-Stack/blob/master/服务端与网络/缓存.md)）

* 长连接：HTTP 1.1 支持长连接和请求的流水线处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

### HTTP2.0 的特点
* 新的二进制格式：HTTP/2 采用二进制格式而非文本格式 
* 多路复用：HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个 HTTP 连接就可以实现多个请求响应  
* header 压缩：使用报头压缩，HTTP/2 降低了开销 
* 服务器推送：HTTP/2 让服务器可以将响应主动"推送"到客户端缓存中

多路复用是指以同一线路承载多路信号进行通信的方式。各路信号在送往传输媒质以前，需按一定的规则进行调制，以利于各路已调信号在媒质中传输，并不致混淆，从而在传到对方时使信号具有足够能量，且可用反调制的方法加以区分、恢复成原信号。多路复用常用的方法有频分多路复用和时分多路复用，码分多路复用的应用也在不断扩大。

## 关于长连接和短连接
　　在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

　　而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：
```javascript
Connection: keep-alive
```
　　在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

　　HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

<br>
<br>

## HTTP 请求方法
* `GET`：获取资源
* `POST`：向指定资源提交实体数据（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立/已有资源的修改。
* `HEAD`：获得报文首部。用于确认 URI 的有效性及资源更新的日期时间等
* `PUT`：从客户端向服务器传送的数据取代指定的文档的内容。PUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存在请求 URI 指定的位置。但是 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。
* `DELETE`：删除资源
* `OPTIONS`：查询支持的方法。查询指定的 URL 能够支持的方法。
* `TRACE`：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 `Max-Forwards` 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。
* `CONNECT`：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输。


<br>
<br>

## HTTPs
HTTP 有以下安全性问题：
1. 通信使用明文，内容可能会被窃听；
2. 不验证通信方的身份，因此有可能遭遇伪装；
3. 无法证明报文的完整性，所以有可能已遭篡改。

　　HTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Socket Layer）通信，再由 SSL 和 TCP 通信。通过使用 SSL，HTTPs 提供了加密、认证和完整性保护。通过使用 **证书** 来对通信方进行认证。证书中有公开密钥数据，如果可以验证公开密钥的确属于通信方的，那么就可以确定通信方是可靠的。
  
　　数字证书认证机构（CA，Certificate Authority）颁发的公开密钥证书，可以通过 CA 对其进行验证。进行 HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，就可以开始加密过程。

<div align="center">
<img src="https://github.com/TanYJie/Technology-Stack-Interview-Experience/blob/master/服务端与网络/image/HTTPs.png"/>
</div>

  
## HTTPS 保证数据安全的机制：
首先科普一下 **对称加密** 和 **非对称加密**:
* 对称加密：加密与解密用的是 **同样的密钥** ，常见的对称加密算法有 DES、3DES、Blowfish、RC4、RC5、RC6、AES 
* 非对称加密：加密与解密用的是 **不同的密钥**。这对密钥被称为 **公钥** 和 **私钥**。非对称加密算法有 RSA

#### HTTPS 具体过程
1. 客户端向服务器端发起 SSL 连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）
2. 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；
3. 客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；
4. 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。
5. 进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。

简单的来说，就是先通过 **非对称加密** 获得 **密钥**，之后用此密钥对数据进行 **对称加密**。


## CA（电子商务认证机构）认证作用： 
　　在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了一对公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。
  
　　为了解决上述问题，一般情况下，服务器端会向 CA 申请认证书，此证书包含了 CA 及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。

<br>
<br>
