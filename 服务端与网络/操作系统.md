# 操作系统

本章内容：
* [进程间通信方式](#进程间通信方式)
* [进程和线程区别](#进程和线程的区别)
* [死锁](#死锁)

## 进程间通信方式 
* **管道 (pipe)**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
* **命名管道 (FIFO)**： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
* **信号量**：信号量用于实现进程间的互斥与同步，也可以用在线程上，主要有 posix 信号量和 System V 信号量，posix 信号量一般用在线程上，System V 信号量一般用在进程上。
* **消息队列 (message queue)**： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。(优先级，大小)
* **共享内存 (shared memory)** ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
* **信号 (signal)** ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。
* **套接字 (socket)**： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

<br>

## 进程和线程的区别
* 进程是资源分配的最小单位，线程是程序执行的最小单位。
* 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，系统开销比较大。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 创建和切换一个线程的开销也比进程要小很多。
* 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。不过如何处理好同步与互斥是编写多线程程序的难点。
* 进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。


#### 进程与线程的选择取决以下几点：
1. 需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。
2. 线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应
3. 因为对 CPU 系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；
4. 并行操作时使用线程，如 C/S 架构的服务器端并发线程响应用户的请求；
5. 需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

<br>

## 死锁
产生死锁的四个必要条件，这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁：
  1. **互斥**：一个资源每次只能被一个进程使用。
  2. **占有且等待**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
  3. **不可抢占**：不可强行占有进程已获得的资源，在未使用完之前，不能强行剥夺。
  4. **循环等待**：若干进程之间形成一种头尾相接的循环等待资源关系。  
  

处理死锁的基本方法：
  * **死锁预防**：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。
  * **死锁避免**：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。
  * **死锁检测**：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。
  * **死锁解除**：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。
