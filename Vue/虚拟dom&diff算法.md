# 为什么使用虚拟 DOM ?        
　　Web 界面由 DOM 树来构建，虚拟 DOM 就是为了解决 **浏览器性能** 问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的内容保存到本地一个 JavaScript 对象`vnode`中，最终将`vnode`与旧的虚拟 DOM 对象`oldVnode`进行对比，形成一个补丁`patch`，然后将`patch`打到浏览器的 DOM 上，形成最终的更新。
  
　　所以，用 JavaScript 对象模拟 DOM 节点的好处是，更新可以先全部反映在 JavaScript 对象上，操作内存中的 JavaScript 对象的速度显然要更快，等更新完成后，再将最终的 JavaScript 对象映射成真实的 DOM，交由浏览器去绘制。
  
# 如何得到 patch ?
　　两棵树如果完全比较时间复杂度是 O(n^3)，但 Vue 的 diff 算法的时间复杂度是 O(n)。要实现这么低的时间复杂度，意味着只能平层的比较两棵树的节点，放弃了深度遍历。这样做，似乎牺牲掉了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层移动 DOM 元素，这样做是最优的。


