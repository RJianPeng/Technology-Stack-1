# 垃圾回收

### 标记清除
　　JavaScript 最常用的垃圾收集方式是 **标记清除** 。当变量进入环境，就将这个变量标记为 "进入环境"。当变量离开环境时，将其标记为 "离开环境"。<br>
　　垃圾收集器在运行时会给存储在内存中的所有变量加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后，仍被加上标记的变量将视为准备删除的变量。最后，垃圾收集器完成 **内存清除** 工作。
  <br><br>
### 引用计数
　　另一种不太常见的垃圾收集策略叫 **引用计数**。引用计数的含义是跟踪每个值被使用的次数。<br>
　　当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数就是 1 。如果同一个值又被赋给另一个变量，则该值的引用次数加 1 。如果包含这个值引用的变量获得了其他值，那么这个值的引用次数减 1 。<br>
　　当这个值的引用次数变为 0 时，说明没有办法再访问这个值了。当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。
  <br><br>
### 引用计数曾遇到的问题
  1.
　　引用计数曾遇到一个严重的问题：**循环引用**。循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。（Netscape Navigator 3.0 曾经是使用引用计数策略的浏览器）
```javascript
function problem(){
  var ObjectA = new Object();
  var ObjectB = new Object();
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```
　　若使用引用计数的方式，函数执行完毕后，两个对象都离开了作用域，但是 objectA 和 objectB 的引用次数不为 0 ，他们将继续存在。假如这个函数被重复调用多次，就会导致大量内存得不到回收。后来 Netscape Navigator 3.0 也使用了标记清除方式
  
  2.
　　IE 有一部分对象不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的。而 COM 对象的垃圾收集机制采用的就是引用计数策略。在 IE 中涉及 COM 对象，就会存在循环引用的问题。
```javascript
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```
