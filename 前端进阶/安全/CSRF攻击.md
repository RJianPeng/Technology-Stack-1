# CSRF 攻击
　　CSRF（Cross-site request forgery），跨站请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF 攻击是源于 Web 的 **隐式身份验证机制**。Web 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。

　　防御 CSRF 攻击有以下几种方法：
  * [验证码](#验证码)
  * [验证 HTTP Referer 字段](#验证-http-referer-字段)
  * [使用 token（Anti CSRF Token）](#使用-token)
  
<br>

## 验证码
　　在通常情况下，验证码能很好遏制 CSRF 攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。
  
<br>

## 验证 HTTP Referer 字段
　　根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 （http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory） 用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。
  
　　**缺点**：这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。
  
<br>

## 使用 token
　　要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

1. 用户访问某个表单页面。
2. 服务端生成一个 token，放在用户的 Session 中。
3. 在页面表单附带上 token 参数。
4. 用户提交请求后，服务端验证表单中的 token 是否与用户Session 中的 token 一致，一致为合法请求，不是则非法请求。

　　**难点1**：如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后。而对于 POST 请求来说，要在 form 的最后加上 `<input type="hidden" name="csrftoken" value="tokenvalue"/>`，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 `<a>` 和 `<form>` 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。
  
　　**难点2**：难以保证 token 本身的安全性。在 GET 请求中，如果将 token 附在请求地址之后，那么也是十分危险的。

<br>

## 在 HTTP 头中自定义属性并验证
　　这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。
